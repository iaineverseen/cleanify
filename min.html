<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lua Compressor</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Inter:wght@400;500;600&display=swap');

      body {
        font-family: 'Inter', sans-serif;
        background: #0f172a;
      }

      .code-font {
        font-family: 'JetBrains Mono', monospace;
      }

      textarea::-webkit-scrollbar {
        width: 8px;
      }

      textarea::-webkit-scrollbar-track {
        background: #1e293b;
      }

      textarea::-webkit-scrollbar-thumb {
        background: #475569;
        border-radius: 4px;
      }
    </style>
  </head>
  <body class="min-h-screen text-white p-6 md:p-10">
    <div class="max-w-4xl mx-auto">
      <!-- Header -->
      <div class="text-center mb-10">
        <h1 class="text-3xl font-semibold">Lua Compressor</h1>
      </div>
      <!-- Input -->
      <div class="mb-4">
        <div class="flex items-center justify-between mb-2">
          <label class="text-sm text-slate-400">Input</label>
          <label class="cursor-pointer text-sm text-slate-400 hover:text-white transition flex items-center gap-1">
            <span>Upload</span>
            <input type="file" id="fileInput" accept=".lua,.txt" class="hidden">
          </label>
        </div>
        <textarea id="input" class="code-font w-full h-48 p-4 bg-slate-900 border border-slate-700 rounded-lg focus:border-blue-500 focus:outline-none resize-y text-sm text-slate-200" placeholder="Paste your Lua code here..."></textarea>
        <div class="text-right text-xs text-slate-500 mt-1" id="inputSize">0 bytes</div>
      </div>
      <!-- Buttons -->
      <div class="flex gap-3 mb-4">
        <button onclick="compress()" class="flex-1 py-3 bg-blue-600 hover:bg-blue-500 rounded-lg font-medium transition"> Compress </button>
      </div>
      <!-- Output -->
      <div class="mb-4">
        <div class="flex items-center justify-between mb-2">
          <label class="text-sm text-slate-400">Output <span id="ratio" class="text-green-400"></span>
          </label>
          <button onclick="downloadOutput()" class="text-sm text-slate-400 hover:text-white transition">Download</button>
        </div>
        <textarea id="output" class="code-font w-full h-48 p-4 bg-slate-900 border border-slate-700 rounded-lg focus:border-blue-500 focus:outline-none resize-y text-sm text-slate-200" placeholder="Output will appear here..." readonly></textarea>
        <div class="text-right text-xs text-slate-500 mt-1" id="outputSize">0 bytes</div>
      </div>
      <!-- Footer -->
      <p class="text-center text-xs text-slate-600 mt-8">All processing happens in your browser</p>
    </div>
    <!-- Toast -->
    <div id="toast" class="fixed bottom-4 left-1/2 -translate-x-1/2 px-4 py-2 bg-slate-800 text-white text-sm rounded-lg opacity-0 transition-opacity duration-300 pointer-events-none"></div>
    <script>
      // Lua Comment Remover
      function removeLuaComments(code) {
        let result = '';
        let i = 0;
        const len = code.length;
        while (i < len) {
          const char = code[i];
          if (char !== '-' && char !== '"' && char !== "'" && char !== '[') {
            result += char;
            i++;
            continue;
          }
          const nextChar = i + 1 < len ? code[i + 1] : '';
          if (char === "'" || char === '"') {
            const stringResult = parseStringFast(code, i, char, len);
            result += stringResult.content;
            i = stringResult.endIndex;
            continue;
          }
          if (char === '[') {
            const longBracketMatch = matchLongBracketFast(code, i, false, len);
            if (longBracketMatch) {
              result += longBracketMatch.content;
              i = longBracketMatch.endIndex;
              continue;
            }
            result += char;
            i++;
            continue;
          }
          if (char === '-' && nextChar === '-') {
            const afterDashes = i + 2;
            if (afterDashes < len && code[afterDashes] === '[') {
              const commentMatch = matchLongBracketFast(code, afterDashes, true, len);
              if (commentMatch) {
                i = commentMatch.endIndex;
                if (i < len && code[i] === '\n') {
                  result += '\n';
                  i++;
                }
                continue;
              }
            }
            while (i < len && code[i] !== '\n') {
              i++;
            }
            if (i < len && code[i] === '\n') {
              result += '\n';
              i++;
            }
            continue;
          }
          result += char;
          i++;
        }
        return result;
      }

      function parseStringFast(code, startIndex, quoteChar, len) {
        let content = code[startIndex];
        let i = startIndex + 1;
        while (i < len) {
          const char = code[i];
          if (char !== '\\' && char !== quoteChar) {
            content += char;
            i++;
            continue;
          }
          if (char === quoteChar) {
            content += char;
            i++;
            break;
          }
          if (char === '\\' && i + 1 < len) {
            const nextChar = code[i + 1];
            if (nextChar === 'n' || nextChar === 't' || nextChar === 'r' || nextChar === '\\' || nextChar === '"' || nextChar === "'" || nextChar === 'a' || nextChar === 'b' || nextChar === 'f' || nextChar === 'v') {
              content += char + nextChar;
              i += 2;
              continue;
            }
            if (nextChar === '\n') {
              content += char + nextChar;
              i += 2;
              continue;
            }
            if (nextChar === 'z') {
              content += char + nextChar;
              i += 2;
              while (i < len && (code[i] === ' ' || code[i] === '\t' || code[i] === '\n' || code[i] === '\r')) {
                content += code[i];
                i++;
              }
              continue;
            }
            if (nextChar === 'x' && i + 3 < len) {
              const hex1 = code[i + 2];
              const hex2 = code[i + 3];
              if (isHexDigit(hex1) && isHexDigit(hex2)) {
                content += code.slice(i, i + 4);
                i += 4;
                continue;
              }
            }
            if (isDigit(nextChar)) {
              let j = i + 1;
              let decStr = '';
              while (j < len && j < i + 4 && isDigit(code[j])) {
                decStr += code[j];
                j++;
              }
              const val = parseInt(decStr, 10);
              if (val <= 255) {
                content += code.slice(i, j);
                i = j;
                continue;
              }
              content += code.slice(i, i + 2);
              i += 2;
              continue;
            }
            if (nextChar === 'u' && i + 2 < len && code[i + 2] === '{') {
              let j = i + 3;
              let valid = true;
              while (j < len && code[j] !== '}') {
                if (!isHexDigit(code[j])) {
                  valid = false;
                  break;
                }
                j++;
              }
              if (j < len && code[j] === '}' && valid && j > i + 3) {
                content += code.slice(i, j + 1);
                i = j + 1;
                continue;
              }
            }
            content += char;
            i++;
            continue;
          }
          content += char;
          i++;
        }
        return {
          content,
          endIndex: i
        };
      }

      function matchLongBracketFast(code, startIndex, isComment, len) {
        if (startIndex >= len || code[startIndex] !== '[') return null;
        let pos = startIndex + 1;
        let equalsCount = 0;
        while (pos < len && code[pos] === '=') {
          equalsCount++;
          pos++;
        }
        if (pos >= len || code[pos] !== '[') return null;
        pos++;
        let firstValidClose = -1;
        let isolatedClose = -1;
        let endOfLineClose = -1;
        let searchPos = pos;
        while (searchPos < len) {
          if (code[searchPos] === ']') {
            let checkPos = searchPos + 1;
            let foundEquals = 0;
            while (checkPos < len && code[checkPos] === '=') {
              foundEquals++;
              checkPos++;
            }
            if (foundEquals === equalsCount && checkPos < len && code[checkPos] === ']') {
              const closeEnd = checkPos + 1;
              if (firstValidClose < 0) {
                firstValidClose = closeEnd;
              }
              if (isComment) {
                let lineStart = searchPos - 1;
                let onlyWhitespaceBefore = true;
                while (lineStart >= 0 && code[lineStart] !== '\n') {
                  if (code[lineStart].trim() !== '') {
                    onlyWhitespaceBefore = false;
                    break;
                  }
                  lineStart--;
                }
                let lineEnd = closeEnd;
                let onlyWhitespaceAfter = true;
                while (lineEnd < len && code[lineEnd] !== '\n') {
                  if (code[lineEnd].trim() !== '') {
                    onlyWhitespaceAfter = false;
                    break;
                  }
                  lineEnd++;
                }
                if (onlyWhitespaceBefore && onlyWhitespaceAfter && isolatedClose < 0) {
                  isolatedClose = closeEnd;
                  break;
                }
                if (onlyWhitespaceAfter && endOfLineClose < 0) {
                  endOfLineClose = closeEnd;
                }
                searchPos = closeEnd;
                continue;
              }
            } else {
              return {
                content: code.slice(startIndex, closeEnd),
                endIndex: closeEnd
              };
            }
          }
          searchPos++;
        }
        let finalClose = isolatedClose > 0 ? isolatedClose : (endOfLineClose > 0 ? endOfLineClose : firstValidClose);
        if (finalClose > 0) {
          if (isComment) {
            return {
              content: '',
              endIndex: finalClose
            };
          } else {
            return {
              content: code.slice(startIndex, finalClose),
              endIndex: finalClose
            };
          }
        }
        return null;
      }

      function isHexDigit(char) {
        const code = char.charCodeAt(0);
        return (code >= 48 && code <= 57) || (code >= 65 && code <= 70) || (code >= 97 && code <= 102);
      }

      function isDigit(char) {
        const code = char.charCodeAt(0);
        return code >= 48 && code <= 57;
      }
      // Optimized LZW Compressor
      const LZW = {
        // Safe chars for Lua strings (no \, ', ", or control chars)
        CHARS: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+-*/=<>!@#$%^&()[]{}|;:,.?~ ',
        encode(codes) {
          // Variable-bit encoding into bytes
          const bytes = [];
          let bits = 0,
            numBits = 0;
          let bitWidth = 9,
            threshold = 512,
            dictSize = 258;
          for (const code of codes) {
            bits |= code << numBits;
            numBits += bitWidth;
            while (numBits >= 8) {
              bytes.push(bits & 255);
              bits >>= 8;
              numBits -= 8;
            }
            dictSize++;
            if (dictSize > threshold && bitWidth < 16) {
              bitWidth++;
              threshold <<= 1;
            }
          }
          if (numBits > 0) bytes.push(bits);
          // Base85-like encoding
          let result = '';
          const chars = this.CHARS;
          for (let i = 0; i < bytes.length; i += 4) {
            let val = bytes[i] || 0;
            val += (bytes[i + 1] || 0) << 8;
            val += (bytes[i + 2] || 0) << 16;
            val += (bytes[i + 3] || 0) << 24;
            val = val >>> 0;
            for (let j = 0; j < 5; j++) {
              result += chars[val % 85];
              val = Math.floor(val / 85);
            }
          }
          return result;
        },
        decode(str) {
          const chars = this.CHARS;
          // Decode base85
          const bytes = [];
          for (let i = 0; i < str.length; i += 5) {
            let val = 0,
              mul = 1;
            for (let j = 0; j < 5 && i + j < str.length; j++) {
              val += chars.indexOf(str[i + j]) * mul;
              mul *= 85;
            }
            bytes.push(val & 255, (val >> 8) & 255, (val >> 16) & 255, (val >> 24) & 255);
          }
          // Variable-bit decoding
          const codes = [];
          let bits = 0,
            numBits = 0,
            byteIdx = 0;
          let bitWidth = 9,
            threshold = 512,
            dictSize = 258;
          while (byteIdx < bytes.length || numBits >= bitWidth) {
            while (numBits < bitWidth && byteIdx < bytes.length) {
              bits |= bytes[byteIdx++] << numBits;
              numBits += 8;
            }
            if (numBits < bitWidth) break;
            const code = bits & ((1 << bitWidth) - 1);
            bits >>= bitWidth;
            numBits -= bitWidth;
            codes.push(code);
            dictSize++;
            if (dictSize > threshold && bitWidth < 16) {
              bitWidth++;
              threshold <<= 1;
            }
          }
          return codes;
        },
        compress(input) {
          if (!input) return '';
          // Remove comments first
          input = removeLuaComments(input);
          // Remove empty lines and trim
          input = input.split('\n').filter(line => line.trim() !== '').join('\n');
          if (input.length === 0) return 'return loadstring("")()';
          // UTF-8 encode
          const bytes = new TextEncoder().encode(input);
          // LZW compress
          const dict = new Map();
          for (let i = 0; i < 256; i++) dict.set(String.fromCharCode(i), i);
          let dictSize = 256;
          let w = '';
          const codes = [];
          for (const byte of bytes) {
            const c = String.fromCharCode(byte);
            const wc = w + c;
            if (dict.has(wc)) {
              w = wc;
            } else {
              codes.push(dict.get(w));
              if (dictSize < 65536) dict.set(wc, dictSize++);
              w = c;
            }
          }
          if (w) codes.push(dict.get(w));
          const encoded = this.encode(codes);
          const numCodes = codes.length;
          // Compact self-extracting Lua
          return `return(function(s,n)local C="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+-*/=<>!@#$%^&()[]{}|;:,.?~ "local B,b,m,w,t,z={},0,0,9,512,258;for i=1,#s,5 do local v=0;for j=0,4 do local c=s:sub(i+j,i+j)local p=C:find(c,1,true)or 1;v=v+(p-1)*85^j end;B[#B+1]=v%256;B[#B+1]=math.floor(v/256)%256;B[#B+1]=math.floor(v/65536)%256;B[#B+1]=math.floor(v/16777216)%256 end;local E,bi,nb={},1,0;for i=1,n do while nb
						<w do b=b+(B[bi]or 0)*2^nb;bi=bi+1;nb=nb+8 end;E[i]=b%2^w;b=math.floor(b/2^w);nb=nb-w;z=z+1;if z>t and w
							<16 then w=w+1;t=t*2 end end;local D,R={},{}for i=0,255 do D[i]=string.char(i)end;local p=D[E[1]]R[1]=p;local dn=256;for i=2,n do local c=E[i]local e=D[c]if e then R[i]=e;D[dn]=p..e:sub(1,1)elseif c==dn then e=p..p:sub(1,1);R[i]=e;D[dn]=e end;dn=dn+1;p=e end;return loadstring(table.concat(R))end)("${encoded}",${numCodes})(...)`;
        },
        decompress(input) {
          if (!input) return '';
          if (input.includes('loadstring("")')) return '';
          // Extract data and count
          const match = input.match(/\("([^"]+)",(\d+)\)/);
          if (!match) throw new Error('Invalid format');
          const encoded = match[1];
          const numCodes = parseInt(match[2]);
          const allCodes = this.decode(encoded);
          const codes = allCodes.slice(0, numCodes);
          // LZW decompress
          const dict = [];
          for (let i = 0; i < 256; i++) dict[i] = String.fromCharCode(i);
          let w = dict[codes[0]];
          const result = [w];
          let dictSize = 256;
          for (let i = 1; i < codes.length; i++) {
            const code = codes[i];
            let entry;
            if (dict[code] !== undefined) {
              entry = dict[code];
            } else if (code === dictSize) {
              entry = w + w[0];
            } else {
              break;
            }
            result.push(entry);
            dict[dictSize++] = w + entry[0];
            w = entry;
          }
          // Decode UTF-8
          const byteArr = new Uint8Array(result.join('').split('').map(c => c.charCodeAt(0)));
          return new TextDecoder().decode(byteArr);
        }
      };
      // DOM
      const input = document.getElementById('input');
      const output = document.getElementById('output');
      const inputSize = document.getElementById('inputSize');
      const outputSize = document.getElementById('outputSize');
      const ratio = document.getElementById('ratio');

      function updateSizes() {
        const inBytes = new Blob([input.value]).size;
        const outBytes = new Blob([output.value]).size;
        inputSize.textContent = formatBytes(inBytes);
        outputSize.textContent = formatBytes(outBytes);
        if (inBytes > 0 && outBytes > 0) {
          const pct = ((1 - outBytes / inBytes) * 100).toFixed(1);
          ratio.textContent = pct > 0 ? `(${pct}% smaller)` : pct < 0 ? `(${Math.abs(pct)}% larger)` : '';
          ratio.className = pct >= 0 ? 'text-green-400' : 'text-yellow-400';
        } else {
          ratio.textContent = '';
        }
      }

      function formatBytes(bytes) {
        if (bytes === 0) return '0 bytes';
        if (bytes === 1) return '1 byte';
        if (bytes < 1024) return bytes + ' bytes';
        return (bytes / 1024).toFixed(1) + ' KB';
      }
      input.addEventListener('input', updateSizes);

      function compress() {
        if (!input.value.trim()) return toast('Enter some code first');
        try {
          output.value = LZW.compress(input.value);
          updateSizes();
          toast('Compressed!');
        } catch (e) {
          toast('Compression failed');
        }
      }

      function downloadOutput() {
        if (!output.value) return toast('Nothing to download');
        const blob = new Blob([output.value], {
          type: 'text/plain'
        });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'script.lua';
        a.click();
        URL.revokeObjectURL(a.href);
      }
      document.getElementById('fileInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            input.value = e.target.result;
            updateSizes();
          };
          reader.readAsText(file);
        }
      });

      function toast(msg) {
        const t = document.getElementById('toast');
        t.textContent = msg;
        t.style.opacity = '1';
        setTimeout(() => t.style.opacity = '0', 2000);
      }
    </script>
  </body>
</html>